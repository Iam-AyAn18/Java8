1. Why annotations are used?
Answer :
Annotations in Java serve various purposes and provide additional information to the compiler, runtime, or other tools. Here are some common reasons why annotations are used:
a. Metadata: Annotations can be used to add metadata or additional information to Java code elements like classes, methods, fields, or parameters. 
This metadata can be used by tools or frameworks for various purposes, such as configuration, documentation generation, code analysis, or runtime behavior.
b. Compiler Instructions: Annotations can provide instructions to the compiler for performing specific tasks or applying certain behaviors during the compilation process. 
For example, the `@Override` annotation is used to indicate that a method overrides a superclass method, allowing the compiler to perform a compile-time check for correctness.
c. Frameworks and Libraries: Many frameworks and libraries use annotations to enable or configure specific features or behaviors. 
For instance, in the case of dependency injection frameworks like Spring, annotations are used to mark classes as components, specify bean configurations, or define injection points.
d. Code Generation: Annotations can be used for code generation purposes. They can trigger code generation tools or processors to generate additional code based on the annotated elements. 
This is often used for generating boilerplate code, reducing manual coding efforts, or integrating with other systems.
e. Runtime Reflection: Annotations can be accessed at runtime through reflection to inspect or modify the behavior of annotated elements. 
This allows runtime frameworks or tools to dynamically adapt or customize the behavior based on the presence or values of annotations.
Overall, annotations provide a flexible and extensible mechanism to enhance Java code with additional information, enable framework features, guide tools, or automate code generation. 
They help in improving code readability, maintainability, and enable better integration with the broader Java ecosystem.

2. Function Interface and Lambda Expression:
Answer:

Lambda Expressions can be defined as methods without names i.e anonymous functions. Like methods, they also have parameters, a body, a return type and possible list of exceptions that can be thrown. 
But unlike methods, neither they have names nor they are associated with any particular class.
@FunctionalInterface
public interface Comparator<T>
{
    int compare(T o1, T o2);       //Only one abstract method
}

	
Comparator<Student> idComparator = (Student s1, Student s2) -> s1.getID()-s2.getID();

if(idComparator.compare(Student ayan, Student sayan))
{
	//do something
}

3. Lambda Expression and method reference:
Answer:
(String s)->Interger.parseInt(s) = Integer::parseInt
(String s)-> s.toLowerCase(s) = String::toLowerCase
(int i)-> System.out.println(i) = System.out::println
(Student s)->s.getName() = Student::getName
()->s.getName() = s::getName
()->new Student() = Student::new

4. What are some built-in functional interfaces in Java?
Answer:
Java provides several built-in functional interfaces in the java.util.function package, such as 
Function interface -> abstract method
- Predicate -> test, 
- Function -> apply, 
- Consumer -> accept, 
- Supplier -> get. 
These interfaces encapsulate common functional patterns and can be used directly or as a basis for defining custom functional interfaces.

5. What is Interface?
Answer:
An interface in Java is a reference type that is used to define a contract or a set of methods that a class must implement. 
It defines a set of abstract methods, constants, and default methods that can be implemented by classes.
An interface provides a way to achieve abstraction, as it separates the definition of methods from their implementation.
- can define constants
- supports multiple inheritance
- can have default method (method with defination can be used as-is or overiden in implemetation)

6. Abstract Class VS Interface
Answer:

Contructor -  Abstract Class- supports ** Interface- doesn't have
Default Method -  Abstract Class- doesn't supports ** Interface- can have default method (method with defination can be used as-is or overiden in implemetation)
Accessibility - Abstract class - Support all public, private, protected ** Interface doesn't support anything other than pulic
Multiple Inheritance - Abstract class - doesn't support ** Interface - Supports
Methods - Inheritance supports static methods as well as fields with abstract method but doesn't support final methods (support non final method) but it only supports final fields 
** Abstract class - supports final, non final methods, and final non-final fields.

7. Static method vs Final method:
Answer:
Static Methods:
Static methods belong to the class itself, not to any specific instance of the class.
They can be called directly on the class without creating an object of the class.
Static methods can access only static variables and other static methods of the class.
They cannot access non-static (instance) variables or methods directly.
Static methods can be overridden in subclasses, but the subclass method will hide the superclass method, not override it.

Final Methods:
Final methods cannot be overridden by subclasses. Once a method is declared as final in a class, it cannot be overridden in any subclass.
They provide the guarantee that the method implementation cannot be changed by subclasses.
Final methods can be inherited by subclasses, but they cannot be modified or overridden.
Final methods are often used to enforce a specific behavior that should not be changed in subclasses.
Final methods can be static or non-static.

8. Static Variable
Answer:

public class StaticVariable {
    public static int counter=0;

    public static void main(String[] args) {
        StaticVariable obj1 = new StaticVariable();
        StaticVariable obj2 = new StaticVariable();

        StaticVariable.counter = 5; // Modify counter through class object
        System.out.println(obj2.counter); // Access counter through obj2, the value will be 5
    }
}
output : 5

Static variable is shared among the other instances of the class.

9. After Java 8, what do you think about Java? Is it still an object oriented language or it has turned into functional programming language?
Answer:
Java is still an object oriented language where everything is done keeping objects (data) in mind. 
But, with the introduction of new features in Java 8, you can use Java as a functional programming language also. 
You can treat it as as an added advantage over the other languages which are either object oriented or functions oriented. 
From Java 8, you can use Java either in an object-oriented programming paradigm or in a functional programming paradigm. 
It supports both.

10. Which type of resource loading do Java 8 streams support? Lazy Loading OR Eager Loading?
Answer:
Lazy Loading.

Lazy Loading is a technique where the data is loaded on-demand or when it is actually needed.
Eager Loading is the opposite of lazy loading, where the data is loaded upfront or eagerly.
With eager loading, all related data or objects are loaded immediately, even if they might not be accessed or used immediately.
They are not specific to Java 8 streams but can be applied in various contexts, including data access, object-relational mapping (ORM).

11. Stream API operations
Answer:
Streams can be defined as a sequences of elements from a source which support data processing operations. You can treat streams as operations on data. 

Intermediate Operations:
filter: Filters the elements based on a given predicate.
map: Transforms each element of the stream to another value using a given function.
flatMap: Flattens a stream of streams into a single stream.
distinct: Returns a stream with distinct elements.
sorted: Sorts the elements of the stream.
limit: Limits the number of elements in the stream.
skip: Skips the specified number of elements in the stream.

Terminal Operations:
forEach: Performs an action on each element of the stream.
collect: Collects the elements of the stream into a collection or other data structure.
reduce: Performs a reduction operation on the elements of the stream.
min: Returns the minimum element of the stream based on a comparator.
max: Returns the maximum element of the stream based on a comparator.
count: Returns the count of elements in the stream.
anyMatch: Returns true if any element of the stream matches the given predicate.
allMatch: Returns true if all elements of the stream match the given predicate.
noneMatch: Returns true if no element of the stream matches the given predicate.
findFirst: Returns the first element of the stream.
findAny: Returns any element of the stream.

Short-circuiting Operations:
anyMatch, allMatch, noneMatch, findFirst, and findAny

12. Characteristics Of Java 8 Streams.
Answer:

- Streams are not the data structures

- Stream Consumes a data source

- Intermediate And Terminal Operations

- Pipeline Of Operations
A pipeline of operations consists of three things – a source, one or more intermediate operations and a terminal operation.
int array is the source, filter() and distinct() are intermediate operations and forEach() is a terminal operation
IntStream.of(new int[] {4, 7, 1, 8, 3, 9, 7}).filter((int i) -> i > 5).distinct().forEach(System.out::println);

- Internal Iteration

- Parallel Execution
To gain the performance while processing the large amount of data, you have to process it in parallel and use multi core architectures.
names.parallelStream().filter()

- Streams are lazily populated

- Streams are traversable only once

- Short Circuiting Operations

13. Shallow Copy VS Deep Copy
Answer:
Cloning is a process of creating an exact copy of an existing object in the memory. 
In Java, clone() method of java.lang.Object class is used for cloning process.

Shallow Copy:
The default version of clone() method creates the shallow copy of an object. The shallow copy of an object will have exact copy of all the fields of original object. 
If original object has any references to other objects as fields, then only references of those objects are copied into clone object, copy of those objects are not created. 
That means any changes made to those objects through clone object will be reflected in original object or vice-versa. 

Student class -> original class
Student class -> clone class
if we make changes into student class via clone class then it will reflect in the student class of original class

Deep Copy:
Deep copy of an object will have exact copy of all the fields of original object just like shallow copy. 
But in additional, if original object has any references to other objects as fields, then copy of those objects are also created by calling clone() method on them.

Student class -> original class
Student class -> clone class
if we make changes into student class via clone class it won't make in difference for student class of original class. both are 100% disjoint from one another.

14. What is Marker Interface?
Answer:
Marker interfaces in java are interfaces with no members declared in them. 
They are just an empty interfaces used to mark or identify a special operation.
Marker interfaces give instructions to JVM that classes implementing them will have special behavior and must be handled with care.
E.g. java.lang.Cloneable Interface, java.io.Serializable Interface

15. Collectors query:
Answer:

- Find number of students of grouping by genders in a stream.
Map<String,int>=Studentlist.stream().collect(collectors.groupingBy(student::getGender,collectors.counting());

- Find if student passed or not, and create a list.
Map<Boolean,int>=Studentlist.stream().collect(collectors.partioningBy(student -> student.getResult()=="pass",collectors.counting());

- Extracting highest, lowest and average of percentage of students.
DoubleSummaryStatistics studentStats = studentList.stream().collect(Collectors.summarizingDouble(Student::getPercentage));    
System.out.println("Highest Percentage : "+studentStats.getMax());        
System.out.println("Lowest Percentage : "+studentStats.getMin());      
System.out.println("Average Percentage : "+studentStats.getAverage());

16.Optional Class.
Answer:
The Optional class in Java is a container object that may or may not contain a non-null value. 
It is designed to handle situations where a value may be present or absent, providing a more expressive and safer alternative to using null references.
Optional<String> nullValue = Optional.empty();
Optional<String> actualValue = Optional.of("Hello");
System.out.println(actualValue.get());

17. Spliterator in JAVA 8. Iterator vs Spliterator
Answer:
Spliterator is an interface introduced from Java 8 as a member of java.util package.
It can be used for both, partitioning as well as iterating.

Iterator - only performs iteration. Spliterator - performs both iteration and splitting
Iterator - only performs iteration one by one. Spliterator - can perform both in bulk or one by one.
Iterator - suitable for serial processing. Spliterator - can do parallel processing as it can split.
Iterator - size is unknown. Spliterator - approx size is known.

18. Hashmap and it's properties.
Answer:
HashMap is a popular implementation of Map interface which holds the data as key-value pairs.

Properties Of HashMap In Java :
1) HashMap holds the data in the form of key-value pairs where each key is associated with one value.
2) HashMap doesn’t allow duplicate keys. But it can have duplicate values.
3) HashMap can have multiple null values and only one null key.
4) HashMap is not synchronized. To get the synchronized HashMap, use Collections.synchronizedMap() method.
5) HashMap maintains no order.
6) HashMap gives constant time performance for the operations like get() and put() methods.
7) Default initial capacity of HashMap is 16.

HashMap<String, Double> map = new HashMap<String, Double>();
map.put("Ashwin", 87.55);
Set set = map.keySet();
Iterator keySetIterator = set.iterator();
while (keySetIterator.hasNext()) 
{
	Object key = keySetIterator.next();
	System.out.println(key+"  : "+map.get(key));
}

*********
Hashmap with stream api
(we need to use entrySet() to use stream())
map.entrySet()
.stream()
.map(s->s.getKey()=="Ashwin")
.forEach(System.out::println)

19. How Hashmap works?
Answer:
Whenever you insert new key-value pair using put() method, HashMap blindly doesn’t allocate slot in the table[] array. 
Instead it calls hash function on the key. HashMap has its own hash function to calculate the hash code of the key. 
This function is implemented so that it overcomes poorly implemented hashCode() methods.
After calculating the hash code of the key, it calls indexFor() method by passing the hash code of the key and length of the table[] array. 
This method returns the index in the table[] array for that particular key-value pair.

below are the steps for put() -
Step 1 : First checks whether the key is null or not. If the key is null, it calls putForNullKey() method. table[0] is always reserved for null key. Because, hash code of null is 0.
Step 2 : If the key is not null, then it calculates the hash code of the key by calling hash() method.
Step 3 : Calls indexFor() method by passing the hash code calculated in step 2 and length of the table[] array. This method returns index in table[] array for the specified key-value pair.
Step 4 : After getting the index, it checks all keys present in the linked list at that index ( or bucket). If the key is already present in the linked list, it replaces the old value with new value.
Step 5 : If the key is not present in the linked list, it appends the specified key-value pair at the end of the linked list.

Step 1, 2, 3 is same for get() -
Step 4 : After getting index, it will iterate though linked list at that position and checks for the key using equals() method. If the key is found, it returns the value associated with it. otherwise returns null.

20. HashSet and it's properties:
Answer:
The HashSet class in Java is an implementation of Set interface. HashSet is a collection of objects which contains only unique elements. 
Duplicates are not allowed in HashSet. HashSet gives constant time performance for insertion, removal and retrieval operations. 
It allows only one null element.

Properties of HashSet :
1) HashSet class internally uses HashMap to store the objects. The elements you enter into HashSet will be stored as keys of HashMap and their values will be a constant.
2) HashSet does not allow duplicate elements. If you try to insert a duplicate element, older element will be overwritten.
3) HashSet can have maximum one null element.
4) HashSet doesn’t maintain any order. The order of the elements will be largely unpredictable. And it also doesn’t guarantee that order will remain constant over time.
5) HashSet offers constant time performance for insertion, removal and retrieval operations.
6) HashSet class is not synchronized. If you want synchronized HashSet, use Collections.synchronizedSet() method.


21. HashMap vs HashSet
Asnwer:
			HashSet											HashMap
HashSet implements Set interface.				HashMap implements Map interface.
HashSet stores the data as objects.				HashMap stores the data as key-value pairs.
HashSet internally uses HashMap.				HashMap internally uses an array of Entry<K, V> objects.
HashSet doesn’t allow duplicate elements.		HashMap doesn’t allow duplicate keys, but allows duplicate values.
HashSet allows only one null element.			HashMap allows one null key and multiple null values.
Insertion operation requires only one object.	Insertion operation requires two objects, key and value.
HashSet is slightly slower than HashMap.		HashMap is slightly faster than HashSet.


22. How HashSet works?
Answer:
Whenever you insert an element into HashSet using add() method, it actually creates an entry in the internally backing HashMap object with 
element you have specified as it’s key and constant called “PRESENT” as it’s value.

set.add("orange"); means map.put("orange",PRESENT);

23. Threads in Java
Answer:
Thread is a smallest executable unit of a process. Thread has it’s own path of execution in a process. A process can have multiple threads.

class Thread1 extends Thread {
	@Override
	public void run() {
		for (int i = 0; i <= 1000; i++) {
			System.out.println(i);
		}
	}
}

//Defining second thread with task
//The task of this thread is to print the numbers from 1001 to 2000
class Thread2 extends Thread {
	@Override
	public void run() {
		for (int i = 1001; i <= 2000; i++) {
			System.out.println(i);
		}
	}
}

public class ThreadsInJava {
//Main Thread
	public static void main(String[] args) {
//Creating first thread
		Thread1 t1 = new Thread1();
		t1.start();

//Creating second thread
		Thread2 t2 = new Thread2();
		t2.start();
	}
}


start()							It starts execution of a thread. It internally calls run() method.
run()							It contains main task to be performed by the thread.
sleep()							It makes the currently executing thread to pause it’s execution for a specified period of time. When the thread is going for sleep, it does not release the locks it holds.
wait()							It makes the currently executing thread to release the lock of this object and wait until some other thread notifies it.
notify()						It wakes up one thread randomly which is waiting for this object’s lock.
notifyAll()						It wakes up all thread which are waiting for this object’s lock. But, only one thread will acquire lock of this object depending upon the priority.
join()							Using this method, you can make the currently executing thread to wait for some other threads to finish their task.
isAlive()						It checks whether a thread is alive or not.
isDaemon()						It checks whether a thread is daemon thread or user thread.
getId()							It returns ID of a thread.
getState()						It returns current state of a thread.
getName() and setName()			Getter and setter for name of a thread
getPriority() and setPriority()	Getter and setter for priority of a thread.
getThreadGroup()				It returns a thread group to which this thread belongs to.
interrupt()						It is used to interrupt a thread.
isInterrupted()					It checks whether a thread is interrupted or not.
setDaemon()						It sets daemon status of a thread.
currentThread()					It returns a reference to currently executing thread.
yield()							It causes the currently executing thread to temporarily pause its execution and allow other threads to execute.


24. ProceedingJoinPoint vs JoinPoint?
Answer : JoinPoint is the core interface in AspectJ that represents a point during the execution of a program. 
It provides access to information about the current joinpoint, which is a specific point in the execution of a program where an aspect can be applied. 
JoinPoint allows you to obtain information such as the method being executed, its arguments, the target object, and more. 
However, JoinPoint doesn't provide the ability to proceed with the execution of the intercepted method.

ProceedingJoinPoint is a subinterface of JoinPoint and provides additional functionality specifically for advice that needs to proceed with the execution of the intercepted method. 
It extends JoinPoint and adds methods like proceed() and proceed(Object[] args) that allow you to continue the execution of the intercepted method or modify its arguments.
used in @around